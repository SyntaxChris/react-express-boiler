'use strict';

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.recursivePatternCapture = recursivePatternCapture;

var _es6Map = require('es6-map');

var _es6Map2 = _interopRequireDefault(_es6Map);

var _fs = require('fs');

var fs = _interopRequireWildcard(_fs);

var _crypto = require('crypto');

var _doctrine = require('doctrine');

var doctrine = _interopRequireWildcard(_doctrine);

var _parse2 = require('./parse');

var _parse3 = _interopRequireDefault(_parse2);

var _resolve = require('./resolve');

var _resolve2 = _interopRequireDefault(_resolve);

var _ignore = require('./ignore');

var _ignore2 = _interopRequireDefault(_ignore);

var _hash = require('./hash');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var exportCache = new _es6Map2.default();

/**
 * detect exports without a full parse.
 * used primarily to ignore the import/ignore setting, iif it looks like
 * there might be something there (i.e., jsnext:main is set).
 * @type {RegExp}
 */
var hasExports = new RegExp('(^|[\\n;])\\s*export\\s[\\w{*]');

var ExportMap = function () {
  function ExportMap(path) {
    _classCallCheck(this, ExportMap);

    this.path = path;
    this.namespace = new _es6Map2.default();
    // todo: restructure to key on path, value is resolver + map of names
    this.reexports = new _es6Map2.default();
    this.dependencies = new _es6Map2.default();
    this.errors = [];
  }

  ExportMap.get = function get(source, context) {

    var path = (0, _resolve2.default)(source, context);
    if (path == null) return null;

    return ExportMap.for(path, context);
  };

  ExportMap.for = function _for(path, context) {
    var exportMap = void 0;

    var cacheKey = (0, _hash.hashObject)((0, _crypto.createHash)('sha256'), {
      settings: context.settings,
      parserPath: context.parserPath,
      parserOptions: context.parserOptions,
      path: path
    }).digest('hex');

    exportMap = exportCache.get(cacheKey);

    // return cached ignore
    if (exportMap === null) return null;

    var stats = fs.statSync(path);
    if (exportMap != null) {
      // date equality check
      if (exportMap.mtime - stats.mtime === 0) {
        return exportMap;
      }
      // future: check content equality?
    }

    var content = fs.readFileSync(path, { encoding: 'utf8' });

    // check for and cache ignore
    if ((0, _ignore2.default)(path, context) && !hasExports.test(content)) {
      exportCache.set(cacheKey, null);
      return null;
    }

    exportMap = ExportMap.parse(path, content, context);
    exportMap.mtime = stats.mtime;

    exportCache.set(cacheKey, exportMap);
    return exportMap;
  };

  ExportMap.parse = function parse(path, content, context) {
    var m = new ExportMap(path);

    try {
      var ast = (0, _parse3.default)(content, context);
    } catch (err) {
      m.errors.push(err);
      return m; // can't continue
    }

    var docstyle = context.settings && context.settings['import/docstyle'] || ['jsdoc'];
    var docStyleParsers = {};
    docstyle.forEach(function (style) {
      docStyleParsers[style] = availableDocStyleParsers[style];
    });

    // attempt to collect module doc
    ast.comments.some(function (c) {
      if (c.type !== 'Block') return false;
      try {
        var doc = doctrine.parse(c.value, { unwrap: true });
        if (doc.tags.some(function (t) {
          return t.title === 'module';
        })) {
          m.doc = doc;
          return true;
        }
      } catch (err) {/* ignore */}
      return false;
    });

    var namespaces = new _es6Map2.default();

    function remotePath(node) {
      return (0, _resolve.relative)(node.source.value, path, context.settings);
    }

    function resolveImport(node) {
      var rp = remotePath(node);
      if (rp == null) return null;
      return ExportMap.for(rp, context);
    }

    function getNamespace(identifier) {
      if (!namespaces.has(identifier.name)) return;

      return function () {
        return resolveImport(namespaces.get(identifier.name));
      };
    }

    function addNamespace(object, identifier) {
      var nsfn = getNamespace(identifier);
      if (nsfn) {
        Object.defineProperty(object, 'namespace', { get: nsfn });
      }

      return object;
    }

    ast.body.forEach(function (n) {

      if (n.type === 'ExportDefaultDeclaration') {
        var exportMeta = captureDoc(docStyleParsers, n);
        if (n.declaration.type === 'Identifier') {
          addNamespace(exportMeta, n.declaration);
        }
        m.namespace.set('default', exportMeta);
        return;
      }

      if (n.type === 'ExportAllDeclaration') {
        var _ret = function () {
          var remoteMap = remotePath(n);
          if (remoteMap == null) return {
              v: void 0
            };
          m.dependencies.set(remoteMap, function () {
            return ExportMap.for(remoteMap, context);
          });
          return {
            v: void 0
          };
        }();

        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
      }

      // capture namespaces in case of later export
      if (n.type === 'ImportDeclaration') {
        var ns = void 0;
        if (n.specifiers.some(function (s) {
          return s.type === 'ImportNamespaceSpecifier' && (ns = s);
        })) {
          namespaces.set(ns.local.name, n);
        }
        return;
      }

      if (n.type === 'ExportNamedDeclaration') {
        // capture declaration
        if (n.declaration != null) {
          switch (n.declaration.type) {
            case 'FunctionDeclaration':
            case 'ClassDeclaration':
            case 'TypeAlias':
              // flowtype with babel-eslint parser
              m.namespace.set(n.declaration.id.name, captureDoc(docStyleParsers, n));
              break;
            case 'VariableDeclaration':
              n.declaration.declarations.forEach(function (d) {
                return recursivePatternCapture(d.id, function (id) {
                  return m.namespace.set(id.name, captureDoc(docStyleParsers, d, n));
                });
              });
              break;
          }
        }

        n.specifiers.forEach(function (s) {
          var exportMeta = {};
          var local = void 0;

          switch (s.type) {
            case 'ExportDefaultSpecifier':
              if (!n.source) return;
              local = 'default';
              break;
            case 'ExportNamespaceSpecifier':
              m.namespace.set(s.exported.name, Object.defineProperty(exportMeta, 'namespace', {
                get: function get() {
                  return resolveImport(n);
                }
              }));
              return;
            case 'ExportSpecifier':
              if (!n.source) {
                m.namespace.set(s.exported.name, addNamespace(exportMeta, s.local));
                return;
              }
            // else falls through
            default:
              local = s.local.name;
              break;
          }

          // todo: JSDoc
          m.reexports.set(s.exported.name, { local: local, getImport: function getImport() {
              return resolveImport(n);
            } });
        });
      }
    });

    return m;
  };

  /**
   * Note that this does not check explicitly re-exported names for existence
   * in the base namespace, but it will expand all `export * from '...'` exports
   * if not found in the explicit namespace.
   * @param  {string}  name
   * @return {Boolean} true if `name` is exported by this module.
   */


  ExportMap.prototype.has = function has(name) {
    if (this.namespace.has(name)) return true;
    if (this.reexports.has(name)) return true;

    // default exports must be explicitly re-exported (#328)
    var foundInnerMapName = false;
    if (name !== 'default') {
      this.dependencies.forEach(function (dep) {
        if (!foundInnerMapName) {
          var innerMap = dep();

          // todo: report as unresolved?
          if (innerMap && innerMap.has(name)) foundInnerMapName = true;
        }
      });
    }

    return foundInnerMapName;
  };

  /**
   * ensure that imported name fully resolves.
   * @param  {[type]}  name [description]
   * @return {Boolean}      [description]
   */


  ExportMap.prototype.hasDeep = function hasDeep(name) {
    var _this = this;

    if (this.namespace.has(name)) return { found: true, path: [this] };

    if (this.reexports.has(name)) {
      var _reexports$get = this.reexports.get(name);

      var local = _reexports$get.local;
      var getImport = _reexports$get.getImport;
      var imported = getImport();

      // if import is ignored, return explicit 'null'
      if (imported == null) return { found: true, path: [this] };

      // safeguard against cycles, only if name matches
      if (imported.path === this.path && local === name) return { found: false, path: [this] };

      var deep = imported.hasDeep(local);
      deep.path.unshift(this);

      return deep;
    }

    // default exports must be explicitly re-exported (#328)
    var returnValue = { found: false, path: [this] };
    if (name !== 'default') {
      this.dependencies.forEach(function (dep) {
        if (!returnValue.found) {
          var innerMap = dep();
          // todo: report as unresolved?
          if (innerMap) {

            // safeguard against cycles
            if (innerMap.path !== _this.path) {

              var innerValue = innerMap.hasDeep(name);
              if (innerValue.found) {
                innerValue.path.unshift(_this);
                returnValue = innerValue;
              }
            }
          }
        }
      });
    }

    return returnValue;
  };

  ExportMap.prototype.get = function get(name) {
    var _this2 = this;

    if (this.namespace.has(name)) return this.namespace.get(name);

    if (this.reexports.has(name)) {
      var _reexports$get2 = this.reexports.get(name);

      var local = _reexports$get2.local;
      var getImport = _reexports$get2.getImport;
      var imported = getImport();

      // if import is ignored, return explicit 'null'
      if (imported == null) return null;

      // safeguard against cycles, only if name matches
      if (imported.path === this.path && local === name) return undefined;

      return imported.get(local);
    }

    // default exports must be explicitly re-exported (#328)
    var returnValue = undefined;
    if (name !== 'default') {
      this.dependencies.forEach(function (dep) {
        if (returnValue === undefined) {
          var innerMap = dep();
          // todo: report as unresolved?
          if (innerMap) {

            // safeguard against cycles
            if (innerMap.path !== _this2.path) {

              var innerValue = innerMap.get(name);
              if (innerValue !== undefined) returnValue = innerValue;
            }
          }
        }
      });
    }

    return returnValue;
  };

  ExportMap.prototype.forEach = function forEach(callback, thisArg) {
    var _this3 = this;

    this.namespace.forEach(function (v, n) {
      return callback.call(thisArg, v, n, _this3);
    });

    this.reexports.forEach(function (_ref, name) {
      var getImport = _ref.getImport;
      var local = _ref.local;

      var reexported = getImport();
      // can't look up meta for ignored re-exports (#348)
      callback.call(thisArg, reexported && reexported.get(local), name, _this3);
    });

    this.dependencies.forEach(function (dep) {
      return dep().forEach(function (v, n) {
        return n !== 'default' && callback.call(thisArg, v, n, _this3);
      });
    });
  };

  // todo: keys, values, entries?

  ExportMap.prototype.reportErrors = function reportErrors(context, declaration) {
    context.report({
      node: declaration.source,
      message: 'Parse errors in imported module \'' + declaration.source.value + '\': ' + ('' + this.errors.map(function (e) {
        return e.message + ' (' + e.lineNumber + ':' + e.column + ')';
      }).join(', '))
    });
  };

  _createClass(ExportMap, [{
    key: 'hasDefault',
    get: function get() {
      return this.get('default') != null;
    } // stronger than this.has

  }, {
    key: 'size',
    get: function get() {
      var size = this.namespace.size + this.reexports.size;
      this.dependencies.forEach(function (dep) {
        return size += dep().size;
      });
      return size;
    }
  }]);

  return ExportMap;
}();

/**
 * parse docs from the first node that has leading comments
 * @param  {...[type]} nodes [description]
 * @return {{doc: object}}
 */


exports.default = ExportMap;
function captureDoc(docStyleParsers) {
  var metadata = {};

  // 'some' short-circuits on first 'true'

  for (var _len = arguments.length, nodes = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    nodes[_key - 1] = arguments[_key];
  }

  nodes.some(function (n) {
    if (!n.leadingComments) return false;

    for (var name in docStyleParsers) {
      var doc = docStyleParsers[name](n.leadingComments);
      if (doc) {
        metadata.doc = doc;
      }
    }

    return true;
  });

  return metadata;
}

var availableDocStyleParsers = {
  jsdoc: captureJsDoc,
  tomdoc: captureTomDoc
};

/**
 * parse JSDoc from leading comments
 * @param  {...[type]} comments [description]
 * @return {{doc: object}}
 */
function captureJsDoc(comments) {
  var doc = void 0;

  // capture XSDoc
  comments.forEach(function (comment) {
    // skip non-block comments
    if (comment.value.slice(0, 4) !== '*\n *') return;
    try {
      doc = doctrine.parse(comment.value, { unwrap: true });
    } catch (err) {
      /* don't care, for now? maybe add to `errors?` */
    }
  });

  return doc;
}

/**
  * parse TomDoc section from comments
  */
function captureTomDoc(comments) {
  // collect lines up to first paragraph break
  var lines = [];
  for (var i = 0; i < comments.length; i++) {
    var comment = comments[i];
    if (comment.value.match(/^\s*$/)) break;
    lines.push(comment.value.trim());
  }

  // return doctrine-like object
  var statusMatch = lines.join(' ').match(/^(Public|Internal|Deprecated):\s*(.+)/);
  if (statusMatch) {
    return {
      description: statusMatch[2],
      tags: [{
        title: statusMatch[1].toLowerCase(),
        description: statusMatch[2]
      }]
    };
  }
}

/**
 * Traverse a pattern/identifier node, calling 'callback'
 * for each leaf identifier.
 * @param  {node}   pattern
 * @param  {Function} callback
 * @return {void}
 */
function recursivePatternCapture(pattern, callback) {
  switch (pattern.type) {
    case 'Identifier':
      // base case
      callback(pattern);
      break;

    case 'ObjectPattern':
      pattern.properties.forEach(function (_ref2) {
        var value = _ref2.value;

        recursivePatternCapture(value, callback);
      });
      break;

    case 'ArrayPattern':
      pattern.elements.forEach(function (element) {
        if (element == null) return;
        recursivePatternCapture(element, callback);
      });
      break;
  }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvcmUvZ2V0RXhwb3J0cy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7OztRQXFjZ0IsdUIsR0FBQSx1Qjs7QUFyY2hCOzs7O0FBRUE7O0lBQVksRTs7QUFFWjs7QUFDQTs7SUFBWSxROztBQUVaOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBOzs7Ozs7OztBQUVBLElBQU0sY0FBYyxzQkFBcEI7Ozs7Ozs7O0FBUUEsSUFBTSxhQUFhLElBQUksTUFBSixDQUFXLGdDQUFYLENBQW5COztJQUVxQixTO0FBQ25CLHFCQUFZLElBQVosRUFBa0I7QUFBQTs7QUFDaEIsU0FBSyxJQUFMLEdBQVksSUFBWjtBQUNBLFNBQUssU0FBTCxHQUFpQixzQkFBakI7O0FBRUEsU0FBSyxTQUFMLEdBQWlCLHNCQUFqQjtBQUNBLFNBQUssWUFBTCxHQUFvQixzQkFBcEI7QUFDQSxTQUFLLE1BQUwsR0FBYyxFQUFkO0FBQ0Q7O1lBVU0sRyxnQkFBSSxNLEVBQVEsTyxFQUFTOztBQUUxQixRQUFJLE9BQU8sdUJBQVEsTUFBUixFQUFnQixPQUFoQixDQUFYO0FBQ0EsUUFBSSxRQUFRLElBQVosRUFBa0IsT0FBTyxJQUFQOztBQUVsQixXQUFPLFVBQVUsR0FBVixDQUFjLElBQWQsRUFBb0IsT0FBcEIsQ0FBUDtBQUNELEc7O1lBRU0sRyxpQkFBSSxJLEVBQU0sTyxFQUFTO0FBQ3hCLFFBQUksa0JBQUo7O0FBRUEsUUFBTSxXQUFXLHNCQUFXLHdCQUFXLFFBQVgsQ0FBWCxFQUFpQztBQUNoRCxnQkFBVSxRQUFRLFFBRDhCO0FBRWhELGtCQUFZLFFBQVEsVUFGNEI7QUFHaEQscUJBQWUsUUFBUSxhQUh5QjtBQUloRDtBQUpnRCxLQUFqQyxFQUtkLE1BTGMsQ0FLUCxLQUxPLENBQWpCOztBQU9BLGdCQUFZLFlBQVksR0FBWixDQUFnQixRQUFoQixDQUFaOzs7QUFHQSxRQUFJLGNBQWMsSUFBbEIsRUFBd0IsT0FBTyxJQUFQOztBQUV4QixRQUFNLFFBQVEsR0FBRyxRQUFILENBQVksSUFBWixDQUFkO0FBQ0EsUUFBSSxhQUFhLElBQWpCLEVBQXVCOztBQUVyQixVQUFJLFVBQVUsS0FBVixHQUFrQixNQUFNLEtBQXhCLEtBQWtDLENBQXRDLEVBQXlDO0FBQ3ZDLGVBQU8sU0FBUDtBQUNEOztBQUVGOztBQUVELFFBQU0sVUFBVSxHQUFHLFlBQUgsQ0FBZ0IsSUFBaEIsRUFBc0IsRUFBRSxVQUFVLE1BQVosRUFBdEIsQ0FBaEI7OztBQUdBLFFBQUksc0JBQVUsSUFBVixFQUFnQixPQUFoQixLQUE0QixDQUFDLFdBQVcsSUFBWCxDQUFnQixPQUFoQixDQUFqQyxFQUEyRDtBQUN6RCxrQkFBWSxHQUFaLENBQWdCLFFBQWhCLEVBQTBCLElBQTFCO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQsZ0JBQVksVUFBVSxLQUFWLENBQWdCLElBQWhCLEVBQXNCLE9BQXRCLEVBQStCLE9BQS9CLENBQVo7QUFDQSxjQUFVLEtBQVYsR0FBa0IsTUFBTSxLQUF4Qjs7QUFFQSxnQkFBWSxHQUFaLENBQWdCLFFBQWhCLEVBQTBCLFNBQTFCO0FBQ0EsV0FBTyxTQUFQO0FBQ0QsRzs7WUFFTSxLLGtCQUFNLEksRUFBTSxPLEVBQVMsTyxFQUFTO0FBQ25DLFFBQUksSUFBSSxJQUFJLFNBQUosQ0FBYyxJQUFkLENBQVI7O0FBRUEsUUFBSTtBQUNGLFVBQUksTUFBTSxxQkFBTSxPQUFOLEVBQWUsT0FBZixDQUFWO0FBQ0QsS0FGRCxDQUVFLE9BQU8sR0FBUCxFQUFZO0FBQ1osUUFBRSxNQUFGLENBQVMsSUFBVCxDQUFjLEdBQWQ7QUFDQSxhQUFPLENBQVAsQztBQUNEOztBQUVELFFBQU0sV0FBWSxRQUFRLFFBQVIsSUFBb0IsUUFBUSxRQUFSLENBQWlCLGlCQUFqQixDQUFyQixJQUE2RCxDQUFDLE9BQUQsQ0FBOUU7QUFDQSxRQUFNLGtCQUFrQixFQUF4QjtBQUNBLGFBQVMsT0FBVCxDQUFpQixpQkFBUztBQUN4QixzQkFBZ0IsS0FBaEIsSUFBeUIseUJBQXlCLEtBQXpCLENBQXpCO0FBQ0QsS0FGRDs7O0FBS0EsUUFBSSxRQUFKLENBQWEsSUFBYixDQUFrQixhQUFLO0FBQ3JCLFVBQUksRUFBRSxJQUFGLEtBQVcsT0FBZixFQUF3QixPQUFPLEtBQVA7QUFDeEIsVUFBSTtBQUNGLFlBQU0sTUFBTSxTQUFTLEtBQVQsQ0FBZSxFQUFFLEtBQWpCLEVBQXdCLEVBQUUsUUFBUSxJQUFWLEVBQXhCLENBQVo7QUFDQSxZQUFJLElBQUksSUFBSixDQUFTLElBQVQsQ0FBYztBQUFBLGlCQUFLLEVBQUUsS0FBRixLQUFZLFFBQWpCO0FBQUEsU0FBZCxDQUFKLEVBQThDO0FBQzVDLFlBQUUsR0FBRixHQUFRLEdBQVI7QUFDQSxpQkFBTyxJQUFQO0FBQ0Q7QUFDRixPQU5ELENBTUUsT0FBTyxHQUFQLEVBQVksQyxZQUFnQjtBQUM5QixhQUFPLEtBQVA7QUFDRCxLQVZEOztBQVlBLFFBQU0sYUFBYSxzQkFBbkI7O0FBRUEsYUFBUyxVQUFULENBQW9CLElBQXBCLEVBQTBCO0FBQ3hCLGFBQU8sdUJBQWdCLEtBQUssTUFBTCxDQUFZLEtBQTVCLEVBQW1DLElBQW5DLEVBQXlDLFFBQVEsUUFBakQsQ0FBUDtBQUNEOztBQUVELGFBQVMsYUFBVCxDQUF1QixJQUF2QixFQUE2QjtBQUMzQixVQUFNLEtBQUssV0FBVyxJQUFYLENBQVg7QUFDQSxVQUFJLE1BQU0sSUFBVixFQUFnQixPQUFPLElBQVA7QUFDaEIsYUFBTyxVQUFVLEdBQVYsQ0FBYyxFQUFkLEVBQWtCLE9BQWxCLENBQVA7QUFDRDs7QUFFRCxhQUFTLFlBQVQsQ0FBc0IsVUFBdEIsRUFBa0M7QUFDaEMsVUFBSSxDQUFDLFdBQVcsR0FBWCxDQUFlLFdBQVcsSUFBMUIsQ0FBTCxFQUFzQzs7QUFFdEMsYUFBTyxZQUFZO0FBQ2pCLGVBQU8sY0FBYyxXQUFXLEdBQVgsQ0FBZSxXQUFXLElBQTFCLENBQWQsQ0FBUDtBQUNELE9BRkQ7QUFHRDs7QUFFRCxhQUFTLFlBQVQsQ0FBc0IsTUFBdEIsRUFBOEIsVUFBOUIsRUFBMEM7QUFDeEMsVUFBTSxPQUFPLGFBQWEsVUFBYixDQUFiO0FBQ0EsVUFBSSxJQUFKLEVBQVU7QUFDUixlQUFPLGNBQVAsQ0FBc0IsTUFBdEIsRUFBOEIsV0FBOUIsRUFBMkMsRUFBRSxLQUFLLElBQVAsRUFBM0M7QUFDRDs7QUFFRCxhQUFPLE1BQVA7QUFDRDs7QUFHRCxRQUFJLElBQUosQ0FBUyxPQUFULENBQWlCLFVBQVUsQ0FBVixFQUFhOztBQUU1QixVQUFJLEVBQUUsSUFBRixLQUFXLDBCQUFmLEVBQTJDO0FBQ3pDLFlBQU0sYUFBYSxXQUFXLGVBQVgsRUFBNEIsQ0FBNUIsQ0FBbkI7QUFDQSxZQUFJLEVBQUUsV0FBRixDQUFjLElBQWQsS0FBdUIsWUFBM0IsRUFBeUM7QUFDdkMsdUJBQWEsVUFBYixFQUF5QixFQUFFLFdBQTNCO0FBQ0Q7QUFDRCxVQUFFLFNBQUYsQ0FBWSxHQUFaLENBQWdCLFNBQWhCLEVBQTJCLFVBQTNCO0FBQ0E7QUFDRDs7QUFFRCxVQUFJLEVBQUUsSUFBRixLQUFXLHNCQUFmLEVBQXVDO0FBQUE7QUFDckMsY0FBSSxZQUFZLFdBQVcsQ0FBWCxDQUFoQjtBQUNBLGNBQUksYUFBYSxJQUFqQixFQUF1QjtBQUFBO0FBQUE7QUFDdkIsWUFBRSxZQUFGLENBQWUsR0FBZixDQUFtQixTQUFuQixFQUE4QjtBQUFBLG1CQUFNLFVBQVUsR0FBVixDQUFjLFNBQWQsRUFBeUIsT0FBekIsQ0FBTjtBQUFBLFdBQTlCO0FBQ0E7QUFBQTtBQUFBO0FBSnFDOztBQUFBO0FBS3RDOzs7QUFHRCxVQUFJLEVBQUUsSUFBRixLQUFXLG1CQUFmLEVBQW9DO0FBQ2xDLFlBQUksV0FBSjtBQUNBLFlBQUksRUFBRSxVQUFGLENBQWEsSUFBYixDQUFrQjtBQUFBLGlCQUFLLEVBQUUsSUFBRixLQUFXLDBCQUFYLEtBQTBDLEtBQUssQ0FBL0MsQ0FBTDtBQUFBLFNBQWxCLENBQUosRUFBK0U7QUFDN0UscUJBQVcsR0FBWCxDQUFlLEdBQUcsS0FBSCxDQUFTLElBQXhCLEVBQThCLENBQTlCO0FBQ0Q7QUFDRDtBQUNEOztBQUVELFVBQUksRUFBRSxJQUFGLEtBQVcsd0JBQWYsRUFBd0M7O0FBRXRDLFlBQUksRUFBRSxXQUFGLElBQWlCLElBQXJCLEVBQTJCO0FBQ3pCLGtCQUFRLEVBQUUsV0FBRixDQUFjLElBQXRCO0FBQ0UsaUJBQUsscUJBQUw7QUFDQSxpQkFBSyxrQkFBTDtBQUNBLGlCQUFLLFdBQUw7O0FBQ0UsZ0JBQUUsU0FBRixDQUFZLEdBQVosQ0FBZ0IsRUFBRSxXQUFGLENBQWMsRUFBZCxDQUFpQixJQUFqQyxFQUF1QyxXQUFXLGVBQVgsRUFBNEIsQ0FBNUIsQ0FBdkM7QUFDQTtBQUNGLGlCQUFLLHFCQUFMO0FBQ0UsZ0JBQUUsV0FBRixDQUFjLFlBQWQsQ0FBMkIsT0FBM0IsQ0FBbUMsVUFBQyxDQUFEO0FBQUEsdUJBQ2pDLHdCQUF3QixFQUFFLEVBQTFCLEVBQThCO0FBQUEseUJBQzVCLEVBQUUsU0FBRixDQUFZLEdBQVosQ0FBZ0IsR0FBRyxJQUFuQixFQUF5QixXQUFXLGVBQVgsRUFBNEIsQ0FBNUIsRUFBK0IsQ0FBL0IsQ0FBekIsQ0FENEI7QUFBQSxpQkFBOUIsQ0FEaUM7QUFBQSxlQUFuQztBQUdBO0FBVko7QUFZRDs7QUFFRCxVQUFFLFVBQUYsQ0FBYSxPQUFiLENBQXFCLFVBQUMsQ0FBRCxFQUFPO0FBQzFCLGNBQU0sYUFBYSxFQUFuQjtBQUNBLGNBQUksY0FBSjs7QUFFQSxrQkFBUSxFQUFFLElBQVY7QUFDRSxpQkFBSyx3QkFBTDtBQUNFLGtCQUFJLENBQUMsRUFBRSxNQUFQLEVBQWU7QUFDZixzQkFBUSxTQUFSO0FBQ0E7QUFDRixpQkFBSywwQkFBTDtBQUNFLGdCQUFFLFNBQUYsQ0FBWSxHQUFaLENBQWdCLEVBQUUsUUFBRixDQUFXLElBQTNCLEVBQWlDLE9BQU8sY0FBUCxDQUFzQixVQUF0QixFQUFrQyxXQUFsQyxFQUErQztBQUM5RSxtQkFEOEUsaUJBQ3hFO0FBQUUseUJBQU8sY0FBYyxDQUFkLENBQVA7QUFBeUI7QUFENkMsZUFBL0MsQ0FBakM7QUFHQTtBQUNGLGlCQUFLLGlCQUFMO0FBQ0Usa0JBQUksQ0FBQyxFQUFFLE1BQVAsRUFBZTtBQUNiLGtCQUFFLFNBQUYsQ0FBWSxHQUFaLENBQWdCLEVBQUUsUUFBRixDQUFXLElBQTNCLEVBQWlDLGFBQWEsVUFBYixFQUF5QixFQUFFLEtBQTNCLENBQWpDO0FBQ0E7QUFDRDs7QUFFSDtBQUNFLHNCQUFRLEVBQUUsS0FBRixDQUFRLElBQWhCO0FBQ0E7QUFsQko7OztBQXNCQSxZQUFFLFNBQUYsQ0FBWSxHQUFaLENBQWdCLEVBQUUsUUFBRixDQUFXLElBQTNCLEVBQWlDLEVBQUUsWUFBRixFQUFTLFdBQVc7QUFBQSxxQkFBTSxjQUFjLENBQWQsQ0FBTjtBQUFBLGFBQXBCLEVBQWpDO0FBQ0QsU0EzQkQ7QUE0QkQ7QUFDRixLQXpFRDs7QUEyRUEsV0FBTyxDQUFQO0FBQ0QsRzs7Ozs7Ozs7Ozs7c0JBU0QsRyxnQkFBSSxJLEVBQU07QUFDUixRQUFJLEtBQUssU0FBTCxDQUFlLEdBQWYsQ0FBbUIsSUFBbkIsQ0FBSixFQUE4QixPQUFPLElBQVA7QUFDOUIsUUFBSSxLQUFLLFNBQUwsQ0FBZSxHQUFmLENBQW1CLElBQW5CLENBQUosRUFBOEIsT0FBTyxJQUFQOzs7QUFHOUIsUUFBSSxvQkFBb0IsS0FBeEI7QUFDQSxRQUFJLFNBQVMsU0FBYixFQUF3QjtBQUN0QixXQUFLLFlBQUwsQ0FBa0IsT0FBbEIsQ0FBMEIsVUFBQyxHQUFELEVBQVM7QUFDakMsWUFBSSxDQUFDLGlCQUFMLEVBQXdCO0FBQ3RCLGNBQUksV0FBVyxLQUFmOzs7QUFHQSxjQUFJLFlBQVksU0FBUyxHQUFULENBQWEsSUFBYixDQUFoQixFQUFvQyxvQkFBb0IsSUFBcEI7QUFDckM7QUFDRixPQVBEO0FBUUQ7O0FBRUQsV0FBTyxpQkFBUDtBQUNELEc7Ozs7Ozs7OztzQkFPRCxPLG9CQUFRLEksRUFBTTtBQUFBOztBQUNaLFFBQUksS0FBSyxTQUFMLENBQWUsR0FBZixDQUFtQixJQUFuQixDQUFKLEVBQThCLE9BQU8sRUFBRSxPQUFPLElBQVQsRUFBZSxNQUFNLENBQUMsSUFBRCxDQUFyQixFQUFQOztBQUU5QixRQUFJLEtBQUssU0FBTCxDQUFlLEdBQWYsQ0FBbUIsSUFBbkIsQ0FBSixFQUE4QjtBQUFBLDJCQUNDLEtBQUssU0FBTCxDQUFlLEdBQWYsQ0FBbUIsSUFBbkIsQ0FERDs7QUFBQSxVQUNwQixLQURvQixrQkFDcEIsS0FEb0I7QUFDdEIsVUFBUyxTQUFULGtCQUFTLFNBQVQ7QUFDQSxxQkFBVyxXQUFYOzs7QUFHTixVQUFJLFlBQVksSUFBaEIsRUFBc0IsT0FBTyxFQUFFLE9BQU8sSUFBVCxFQUFlLE1BQU0sQ0FBQyxJQUFELENBQXJCLEVBQVA7OztBQUd0QixVQUFJLFNBQVMsSUFBVCxLQUFrQixLQUFLLElBQXZCLElBQStCLFVBQVUsSUFBN0MsRUFBbUQsT0FBTyxFQUFFLE9BQU8sS0FBVCxFQUFnQixNQUFNLENBQUMsSUFBRCxDQUF0QixFQUFQOztBQUVuRCxVQUFNLE9BQU8sU0FBUyxPQUFULENBQWlCLEtBQWpCLENBQWI7QUFDQSxXQUFLLElBQUwsQ0FBVSxPQUFWLENBQWtCLElBQWxCOztBQUVBLGFBQU8sSUFBUDtBQUNEOzs7QUFJRCxRQUFJLGNBQWMsRUFBRSxPQUFPLEtBQVQsRUFBZ0IsTUFBTSxDQUFDLElBQUQsQ0FBdEIsRUFBbEI7QUFDQSxRQUFJLFNBQVMsU0FBYixFQUF3QjtBQUN0QixXQUFLLFlBQUwsQ0FBa0IsT0FBbEIsQ0FBMEIsVUFBQyxHQUFELEVBQVM7QUFDakMsWUFBSSxDQUFDLFlBQVksS0FBakIsRUFBd0I7QUFDdEIsY0FBSSxXQUFXLEtBQWY7O0FBRUEsY0FBSSxRQUFKLEVBQWM7OztBQUdaLGdCQUFJLFNBQVMsSUFBVCxLQUFrQixNQUFLLElBQTNCLEVBQWlDOztBQUUvQixrQkFBSSxhQUFhLFNBQVMsT0FBVCxDQUFpQixJQUFqQixDQUFqQjtBQUNBLGtCQUFJLFdBQVcsS0FBZixFQUFzQjtBQUNwQiwyQkFBVyxJQUFYLENBQWdCLE9BQWhCO0FBQ0EsOEJBQWMsVUFBZDtBQUNEO0FBQ0Y7QUFDRjtBQUNGO0FBQ0YsT0FqQkQ7QUFrQkQ7O0FBRUQsV0FBTyxXQUFQO0FBQ0QsRzs7c0JBRUQsRyxnQkFBSSxJLEVBQU07QUFBQTs7QUFDUixRQUFJLEtBQUssU0FBTCxDQUFlLEdBQWYsQ0FBbUIsSUFBbkIsQ0FBSixFQUE4QixPQUFPLEtBQUssU0FBTCxDQUFlLEdBQWYsQ0FBbUIsSUFBbkIsQ0FBUDs7QUFFOUIsUUFBSSxLQUFLLFNBQUwsQ0FBZSxHQUFmLENBQW1CLElBQW5CLENBQUosRUFBOEI7QUFBQSw0QkFDQyxLQUFLLFNBQUwsQ0FBZSxHQUFmLENBQW1CLElBQW5CLENBREQ7O0FBQUEsVUFDcEIsS0FEb0IsbUJBQ3BCLEtBRG9CO0FBQ3RCLFVBQVMsU0FBVCxtQkFBUyxTQUFUO0FBQ0EscUJBQVcsV0FBWDs7O0FBR04sVUFBSSxZQUFZLElBQWhCLEVBQXNCLE9BQU8sSUFBUDs7O0FBR3RCLFVBQUksU0FBUyxJQUFULEtBQWtCLEtBQUssSUFBdkIsSUFBK0IsVUFBVSxJQUE3QyxFQUFtRCxPQUFPLFNBQVA7O0FBRW5ELGFBQU8sU0FBUyxHQUFULENBQWEsS0FBYixDQUFQO0FBQ0Q7OztBQUdELFFBQUksY0FBYyxTQUFsQjtBQUNBLFFBQUksU0FBUyxTQUFiLEVBQXdCO0FBQ3RCLFdBQUssWUFBTCxDQUFrQixPQUFsQixDQUEwQixVQUFDLEdBQUQsRUFBUztBQUNqQyxZQUFJLGdCQUFnQixTQUFwQixFQUErQjtBQUM3QixjQUFJLFdBQVcsS0FBZjs7QUFFQSxjQUFJLFFBQUosRUFBYzs7O0FBR1osZ0JBQUksU0FBUyxJQUFULEtBQWtCLE9BQUssSUFBM0IsRUFBaUM7O0FBRS9CLGtCQUFJLGFBQWEsU0FBUyxHQUFULENBQWEsSUFBYixDQUFqQjtBQUNBLGtCQUFJLGVBQWUsU0FBbkIsRUFBOEIsY0FBYyxVQUFkO0FBQy9CO0FBQ0Y7QUFDRjtBQUNGLE9BZEQ7QUFlRDs7QUFFRCxXQUFPLFdBQVA7QUFDRCxHOztzQkFFRCxPLG9CQUFRLFEsRUFBVSxPLEVBQVM7QUFBQTs7QUFDekIsU0FBSyxTQUFMLENBQWUsT0FBZixDQUF1QixVQUFDLENBQUQsRUFBSSxDQUFKO0FBQUEsYUFDckIsU0FBUyxJQUFULENBQWMsT0FBZCxFQUF1QixDQUF2QixFQUEwQixDQUExQixTQURxQjtBQUFBLEtBQXZCOztBQUdBLFNBQUssU0FBTCxDQUFlLE9BQWYsQ0FBdUIsZ0JBQXVCLElBQXZCLEVBQWdDO0FBQUEsVUFBN0IsU0FBNkIsUUFBN0IsU0FBNkI7QUFBQSxVQUFsQixLQUFrQixRQUFsQixLQUFrQjs7QUFDckQsVUFBTSxhQUFhLFdBQW5COztBQUVBLGVBQVMsSUFBVCxDQUFjLE9BQWQsRUFBdUIsY0FBYyxXQUFXLEdBQVgsQ0FBZSxLQUFmLENBQXJDLEVBQTRELElBQTVEO0FBQ0QsS0FKRDs7QUFNQSxTQUFLLFlBQUwsQ0FBa0IsT0FBbEIsQ0FBMEI7QUFBQSxhQUFPLE1BQU0sT0FBTixDQUFjLFVBQUMsQ0FBRCxFQUFJLENBQUo7QUFBQSxlQUM3QyxNQUFNLFNBQU4sSUFBbUIsU0FBUyxJQUFULENBQWMsT0FBZCxFQUF1QixDQUF2QixFQUEwQixDQUExQixTQUQwQjtBQUFBLE9BQWQsQ0FBUDtBQUFBLEtBQTFCO0FBRUQsRzs7OztzQkFJRCxZLHlCQUFhLE8sRUFBUyxXLEVBQWE7QUFDakMsWUFBUSxNQUFSLENBQWU7QUFDYixZQUFNLFlBQVksTUFETDtBQUViLGVBQVMsdUNBQW9DLFlBQVksTUFBWixDQUFtQixLQUF2RCxrQkFDTSxLQUFLLE1BQUwsQ0FDSSxHQURKLENBQ1E7QUFBQSxlQUFRLEVBQUUsT0FBVixVQUFzQixFQUFFLFVBQXhCLFNBQXNDLEVBQUUsTUFBeEM7QUFBQSxPQURSLEVBRUksSUFGSixDQUVTLElBRlQsQ0FETjtBQUZJLEtBQWY7QUFPRCxHOzs7O3dCQTdVZ0I7QUFBRSxhQUFPLEtBQUssR0FBTCxDQUFTLFNBQVQsS0FBdUIsSUFBOUI7QUFBb0MsSzs7Ozt3QkFFNUM7QUFDVCxVQUFJLE9BQU8sS0FBSyxTQUFMLENBQWUsSUFBZixHQUFzQixLQUFLLFNBQUwsQ0FBZSxJQUFoRDtBQUNBLFdBQUssWUFBTCxDQUFrQixPQUFsQixDQUEwQjtBQUFBLGVBQU8sUUFBUSxNQUFNLElBQXJCO0FBQUEsT0FBMUI7QUFDQSxhQUFPLElBQVA7QUFDRDs7Ozs7Ozs7Ozs7OztrQkFoQmtCLFM7QUErVnJCLFNBQVMsVUFBVCxDQUFvQixlQUFwQixFQUErQztBQUM3QyxNQUFNLFdBQVcsRUFBakI7Ozs7QUFENkMsb0NBQVAsS0FBTztBQUFQLFNBQU87QUFBQTs7QUFJN0MsUUFBTSxJQUFOLENBQVcsYUFBSztBQUNkLFFBQUksQ0FBQyxFQUFFLGVBQVAsRUFBd0IsT0FBTyxLQUFQOztBQUV4QixTQUFLLElBQUksSUFBVCxJQUFpQixlQUFqQixFQUFrQztBQUNoQyxVQUFNLE1BQU0sZ0JBQWdCLElBQWhCLEVBQXNCLEVBQUUsZUFBeEIsQ0FBWjtBQUNBLFVBQUksR0FBSixFQUFTO0FBQ1AsaUJBQVMsR0FBVCxHQUFlLEdBQWY7QUFDRDtBQUNGOztBQUVELFdBQU8sSUFBUDtBQUNELEdBWEQ7O0FBYUEsU0FBTyxRQUFQO0FBQ0Q7O0FBRUQsSUFBTSwyQkFBMkI7QUFDL0IsU0FBTyxZQUR3QjtBQUUvQixVQUFRO0FBRnVCLENBQWpDOzs7Ozs7O0FBVUEsU0FBUyxZQUFULENBQXNCLFFBQXRCLEVBQWdDO0FBQzlCLE1BQUksWUFBSjs7O0FBR0EsV0FBUyxPQUFULENBQWlCLG1CQUFXOztBQUUxQixRQUFJLFFBQVEsS0FBUixDQUFjLEtBQWQsQ0FBb0IsQ0FBcEIsRUFBdUIsQ0FBdkIsTUFBOEIsT0FBbEMsRUFBMkM7QUFDM0MsUUFBSTtBQUNGLFlBQU0sU0FBUyxLQUFULENBQWUsUUFBUSxLQUF2QixFQUE4QixFQUFFLFFBQVEsSUFBVixFQUE5QixDQUFOO0FBQ0QsS0FGRCxDQUVFLE9BQU8sR0FBUCxFQUFZOztBQUViO0FBQ0YsR0FSRDs7QUFVQSxTQUFPLEdBQVA7QUFDRDs7Ozs7QUFLRCxTQUFTLGFBQVQsQ0FBdUIsUUFBdkIsRUFBaUM7O0FBRS9CLE1BQU0sUUFBUSxFQUFkO0FBQ0EsT0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFNBQVMsTUFBN0IsRUFBcUMsR0FBckMsRUFBMEM7QUFDeEMsUUFBTSxVQUFVLFNBQVMsQ0FBVCxDQUFoQjtBQUNBLFFBQUksUUFBUSxLQUFSLENBQWMsS0FBZCxDQUFvQixPQUFwQixDQUFKLEVBQWtDO0FBQ2xDLFVBQU0sSUFBTixDQUFXLFFBQVEsS0FBUixDQUFjLElBQWQsRUFBWDtBQUNEOzs7QUFHRCxNQUFNLGNBQWMsTUFBTSxJQUFOLENBQVcsR0FBWCxFQUFnQixLQUFoQixDQUFzQix1Q0FBdEIsQ0FBcEI7QUFDQSxNQUFJLFdBQUosRUFBaUI7QUFDZixXQUFPO0FBQ0wsbUJBQWEsWUFBWSxDQUFaLENBRFI7QUFFTCxZQUFNLENBQUM7QUFDTCxlQUFPLFlBQVksQ0FBWixFQUFlLFdBQWYsRUFERjtBQUVMLHFCQUFhLFlBQVksQ0FBWjtBQUZSLE9BQUQ7QUFGRCxLQUFQO0FBT0Q7QUFDRjs7Ozs7Ozs7O0FBU00sU0FBUyx1QkFBVCxDQUFpQyxPQUFqQyxFQUEwQyxRQUExQyxFQUFvRDtBQUN6RCxVQUFRLFFBQVEsSUFBaEI7QUFDRSxTQUFLLFlBQUw7O0FBQ0UsZUFBUyxPQUFUO0FBQ0E7O0FBRUYsU0FBSyxlQUFMO0FBQ0UsY0FBUSxVQUFSLENBQW1CLE9BQW5CLENBQTJCLGlCQUFlO0FBQUEsWUFBWixLQUFZLFNBQVosS0FBWTs7QUFDeEMsZ0NBQXdCLEtBQXhCLEVBQStCLFFBQS9CO0FBQ0QsT0FGRDtBQUdBOztBQUVGLFNBQUssY0FBTDtBQUNFLGNBQVEsUUFBUixDQUFpQixPQUFqQixDQUF5QixVQUFDLE9BQUQsRUFBYTtBQUNwQyxZQUFJLFdBQVcsSUFBZixFQUFxQjtBQUNyQixnQ0FBd0IsT0FBeEIsRUFBaUMsUUFBakM7QUFDRCxPQUhEO0FBSUE7QUFoQko7QUFrQkQiLCJmaWxlIjoiY29yZS9nZXRFeHBvcnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE1hcCBmcm9tICdlczYtbWFwJ1xuXG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcydcblxuaW1wb3J0IHsgY3JlYXRlSGFzaCB9IGZyb20gJ2NyeXB0bydcbmltcG9ydCAqIGFzIGRvY3RyaW5lIGZyb20gJ2RvY3RyaW5lJ1xuXG5pbXBvcnQgcGFyc2UgZnJvbSAnLi9wYXJzZSdcbmltcG9ydCByZXNvbHZlLCB7IHJlbGF0aXZlIGFzIHJlc29sdmVSZWxhdGl2ZSB9IGZyb20gJy4vcmVzb2x2ZSdcbmltcG9ydCBpc0lnbm9yZWQgZnJvbSAnLi9pZ25vcmUnXG5cbmltcG9ydCB7IGhhc2hPYmplY3QgfSBmcm9tICcuL2hhc2gnXG5cbmNvbnN0IGV4cG9ydENhY2hlID0gbmV3IE1hcCgpXG5cbi8qKlxuICogZGV0ZWN0IGV4cG9ydHMgd2l0aG91dCBhIGZ1bGwgcGFyc2UuXG4gKiB1c2VkIHByaW1hcmlseSB0byBpZ25vcmUgdGhlIGltcG9ydC9pZ25vcmUgc2V0dGluZywgaWlmIGl0IGxvb2tzIGxpa2VcbiAqIHRoZXJlIG1pZ2h0IGJlIHNvbWV0aGluZyB0aGVyZSAoaS5lLiwganNuZXh0Om1haW4gaXMgc2V0KS5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cbmNvbnN0IGhhc0V4cG9ydHMgPSBuZXcgUmVnRXhwKCcoXnxbXFxcXG47XSlcXFxccypleHBvcnRcXFxcc1tcXFxcd3sqXScpXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV4cG9ydE1hcCB7XG4gIGNvbnN0cnVjdG9yKHBhdGgpIHtcbiAgICB0aGlzLnBhdGggPSBwYXRoXG4gICAgdGhpcy5uYW1lc3BhY2UgPSBuZXcgTWFwKClcbiAgICAvLyB0b2RvOiByZXN0cnVjdHVyZSB0byBrZXkgb24gcGF0aCwgdmFsdWUgaXMgcmVzb2x2ZXIgKyBtYXAgb2YgbmFtZXNcbiAgICB0aGlzLnJlZXhwb3J0cyA9IG5ldyBNYXAoKVxuICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gbmV3IE1hcCgpXG4gICAgdGhpcy5lcnJvcnMgPSBbXVxuICB9XG5cbiAgZ2V0IGhhc0RlZmF1bHQoKSB7IHJldHVybiB0aGlzLmdldCgnZGVmYXVsdCcpICE9IG51bGwgfSAvLyBzdHJvbmdlciB0aGFuIHRoaXMuaGFzXG5cbiAgZ2V0IHNpemUoKSB7XG4gICAgbGV0IHNpemUgPSB0aGlzLm5hbWVzcGFjZS5zaXplICsgdGhpcy5yZWV4cG9ydHMuc2l6ZVxuICAgIHRoaXMuZGVwZW5kZW5jaWVzLmZvckVhY2goZGVwID0+IHNpemUgKz0gZGVwKCkuc2l6ZSlcbiAgICByZXR1cm4gc2l6ZVxuICB9XG5cbiAgc3RhdGljIGdldChzb3VyY2UsIGNvbnRleHQpIHtcblxuICAgIHZhciBwYXRoID0gcmVzb2x2ZShzb3VyY2UsIGNvbnRleHQpXG4gICAgaWYgKHBhdGggPT0gbnVsbCkgcmV0dXJuIG51bGxcblxuICAgIHJldHVybiBFeHBvcnRNYXAuZm9yKHBhdGgsIGNvbnRleHQpXG4gIH1cblxuICBzdGF0aWMgZm9yKHBhdGgsIGNvbnRleHQpIHtcbiAgICBsZXQgZXhwb3J0TWFwXG5cbiAgICBjb25zdCBjYWNoZUtleSA9IGhhc2hPYmplY3QoY3JlYXRlSGFzaCgnc2hhMjU2JyksIHtcbiAgICAgIHNldHRpbmdzOiBjb250ZXh0LnNldHRpbmdzLFxuICAgICAgcGFyc2VyUGF0aDogY29udGV4dC5wYXJzZXJQYXRoLFxuICAgICAgcGFyc2VyT3B0aW9uczogY29udGV4dC5wYXJzZXJPcHRpb25zLFxuICAgICAgcGF0aCxcbiAgICB9KS5kaWdlc3QoJ2hleCcpXG5cbiAgICBleHBvcnRNYXAgPSBleHBvcnRDYWNoZS5nZXQoY2FjaGVLZXkpXG5cbiAgICAvLyByZXR1cm4gY2FjaGVkIGlnbm9yZVxuICAgIGlmIChleHBvcnRNYXAgPT09IG51bGwpIHJldHVybiBudWxsXG5cbiAgICBjb25zdCBzdGF0cyA9IGZzLnN0YXRTeW5jKHBhdGgpXG4gICAgaWYgKGV4cG9ydE1hcCAhPSBudWxsKSB7XG4gICAgICAvLyBkYXRlIGVxdWFsaXR5IGNoZWNrXG4gICAgICBpZiAoZXhwb3J0TWFwLm10aW1lIC0gc3RhdHMubXRpbWUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydE1hcFxuICAgICAgfVxuICAgICAgLy8gZnV0dXJlOiBjaGVjayBjb250ZW50IGVxdWFsaXR5P1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMocGF0aCwgeyBlbmNvZGluZzogJ3V0ZjgnIH0pXG5cbiAgICAvLyBjaGVjayBmb3IgYW5kIGNhY2hlIGlnbm9yZVxuICAgIGlmIChpc0lnbm9yZWQocGF0aCwgY29udGV4dCkgJiYgIWhhc0V4cG9ydHMudGVzdChjb250ZW50KSkge1xuICAgICAgZXhwb3J0Q2FjaGUuc2V0KGNhY2hlS2V5LCBudWxsKVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICBleHBvcnRNYXAgPSBFeHBvcnRNYXAucGFyc2UocGF0aCwgY29udGVudCwgY29udGV4dClcbiAgICBleHBvcnRNYXAubXRpbWUgPSBzdGF0cy5tdGltZVxuXG4gICAgZXhwb3J0Q2FjaGUuc2V0KGNhY2hlS2V5LCBleHBvcnRNYXApXG4gICAgcmV0dXJuIGV4cG9ydE1hcFxuICB9XG5cbiAgc3RhdGljIHBhcnNlKHBhdGgsIGNvbnRlbnQsIGNvbnRleHQpIHtcbiAgICB2YXIgbSA9IG5ldyBFeHBvcnRNYXAocGF0aClcblxuICAgIHRyeSB7XG4gICAgICB2YXIgYXN0ID0gcGFyc2UoY29udGVudCwgY29udGV4dClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIG0uZXJyb3JzLnB1c2goZXJyKVxuICAgICAgcmV0dXJuIG0gLy8gY2FuJ3QgY29udGludWVcbiAgICB9XG5cbiAgICBjb25zdCBkb2NzdHlsZSA9IChjb250ZXh0LnNldHRpbmdzICYmIGNvbnRleHQuc2V0dGluZ3NbJ2ltcG9ydC9kb2NzdHlsZSddKSB8fCBbJ2pzZG9jJ11cbiAgICBjb25zdCBkb2NTdHlsZVBhcnNlcnMgPSB7fVxuICAgIGRvY3N0eWxlLmZvckVhY2goc3R5bGUgPT4ge1xuICAgICAgZG9jU3R5bGVQYXJzZXJzW3N0eWxlXSA9IGF2YWlsYWJsZURvY1N0eWxlUGFyc2Vyc1tzdHlsZV1cbiAgICB9KVxuXG4gICAgLy8gYXR0ZW1wdCB0byBjb2xsZWN0IG1vZHVsZSBkb2NcbiAgICBhc3QuY29tbWVudHMuc29tZShjID0+IHtcbiAgICAgIGlmIChjLnR5cGUgIT09ICdCbG9jaycpIHJldHVybiBmYWxzZVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZG9jID0gZG9jdHJpbmUucGFyc2UoYy52YWx1ZSwgeyB1bndyYXA6IHRydWUgfSlcbiAgICAgICAgaWYgKGRvYy50YWdzLnNvbWUodCA9PiB0LnRpdGxlID09PSAnbW9kdWxlJykpIHtcbiAgICAgICAgICBtLmRvYyA9IGRvY1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikgeyAvKiBpZ25vcmUgKi8gfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSlcblxuICAgIGNvbnN0IG5hbWVzcGFjZXMgPSBuZXcgTWFwKClcblxuICAgIGZ1bmN0aW9uIHJlbW90ZVBhdGgobm9kZSkge1xuICAgICAgcmV0dXJuIHJlc29sdmVSZWxhdGl2ZShub2RlLnNvdXJjZS52YWx1ZSwgcGF0aCwgY29udGV4dC5zZXR0aW5ncylcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlSW1wb3J0KG5vZGUpIHtcbiAgICAgIGNvbnN0IHJwID0gcmVtb3RlUGF0aChub2RlKVxuICAgICAgaWYgKHJwID09IG51bGwpIHJldHVybiBudWxsXG4gICAgICByZXR1cm4gRXhwb3J0TWFwLmZvcihycCwgY29udGV4dClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXROYW1lc3BhY2UoaWRlbnRpZmllcikge1xuICAgICAgaWYgKCFuYW1lc3BhY2VzLmhhcyhpZGVudGlmaWVyLm5hbWUpKSByZXR1cm5cblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVJbXBvcnQobmFtZXNwYWNlcy5nZXQoaWRlbnRpZmllci5uYW1lKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGROYW1lc3BhY2Uob2JqZWN0LCBpZGVudGlmaWVyKSB7XG4gICAgICBjb25zdCBuc2ZuID0gZ2V0TmFtZXNwYWNlKGlkZW50aWZpZXIpXG4gICAgICBpZiAobnNmbikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnbmFtZXNwYWNlJywgeyBnZXQ6IG5zZm4gfSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iamVjdFxuICAgIH1cblxuXG4gICAgYXN0LmJvZHkuZm9yRWFjaChmdW5jdGlvbiAobikge1xuXG4gICAgICBpZiAobi50eXBlID09PSAnRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uJykge1xuICAgICAgICBjb25zdCBleHBvcnRNZXRhID0gY2FwdHVyZURvYyhkb2NTdHlsZVBhcnNlcnMsIG4pXG4gICAgICAgIGlmIChuLmRlY2xhcmF0aW9uLnR5cGUgPT09ICdJZGVudGlmaWVyJykge1xuICAgICAgICAgIGFkZE5hbWVzcGFjZShleHBvcnRNZXRhLCBuLmRlY2xhcmF0aW9uKVxuICAgICAgICB9XG4gICAgICAgIG0ubmFtZXNwYWNlLnNldCgnZGVmYXVsdCcsIGV4cG9ydE1ldGEpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAobi50eXBlID09PSAnRXhwb3J0QWxsRGVjbGFyYXRpb24nKSB7XG4gICAgICAgIGxldCByZW1vdGVNYXAgPSByZW1vdGVQYXRoKG4pXG4gICAgICAgIGlmIChyZW1vdGVNYXAgPT0gbnVsbCkgcmV0dXJuXG4gICAgICAgIG0uZGVwZW5kZW5jaWVzLnNldChyZW1vdGVNYXAsICgpID0+IEV4cG9ydE1hcC5mb3IocmVtb3RlTWFwLCBjb250ZXh0KSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIGNhcHR1cmUgbmFtZXNwYWNlcyBpbiBjYXNlIG9mIGxhdGVyIGV4cG9ydFxuICAgICAgaWYgKG4udHlwZSA9PT0gJ0ltcG9ydERlY2xhcmF0aW9uJykge1xuICAgICAgICBsZXQgbnNcbiAgICAgICAgaWYgKG4uc3BlY2lmaWVycy5zb21lKHMgPT4gcy50eXBlID09PSAnSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyJyAmJiAobnMgPSBzKSkpIHtcbiAgICAgICAgICBuYW1lc3BhY2VzLnNldChucy5sb2NhbC5uYW1lLCBuKVxuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAobi50eXBlID09PSAnRXhwb3J0TmFtZWREZWNsYXJhdGlvbicpe1xuICAgICAgICAvLyBjYXB0dXJlIGRlY2xhcmF0aW9uXG4gICAgICAgIGlmIChuLmRlY2xhcmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICBzd2l0Y2ggKG4uZGVjbGFyYXRpb24udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnRnVuY3Rpb25EZWNsYXJhdGlvbic6XG4gICAgICAgICAgICBjYXNlICdDbGFzc0RlY2xhcmF0aW9uJzpcbiAgICAgICAgICAgIGNhc2UgJ1R5cGVBbGlhcyc6IC8vIGZsb3d0eXBlIHdpdGggYmFiZWwtZXNsaW50IHBhcnNlclxuICAgICAgICAgICAgICBtLm5hbWVzcGFjZS5zZXQobi5kZWNsYXJhdGlvbi5pZC5uYW1lLCBjYXB0dXJlRG9jKGRvY1N0eWxlUGFyc2VycywgbikpXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlICdWYXJpYWJsZURlY2xhcmF0aW9uJzpcbiAgICAgICAgICAgICAgbi5kZWNsYXJhdGlvbi5kZWNsYXJhdGlvbnMuZm9yRWFjaCgoZCkgPT5cbiAgICAgICAgICAgICAgICByZWN1cnNpdmVQYXR0ZXJuQ2FwdHVyZShkLmlkLCBpZCA9PlxuICAgICAgICAgICAgICAgICAgbS5uYW1lc3BhY2Uuc2V0KGlkLm5hbWUsIGNhcHR1cmVEb2MoZG9jU3R5bGVQYXJzZXJzLCBkLCBuKSkpKVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG4uc3BlY2lmaWVycy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgY29uc3QgZXhwb3J0TWV0YSA9IHt9XG4gICAgICAgICAgbGV0IGxvY2FsXG5cbiAgICAgICAgICBzd2l0Y2ggKHMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnRXhwb3J0RGVmYXVsdFNwZWNpZmllcic6XG4gICAgICAgICAgICAgIGlmICghbi5zb3VyY2UpIHJldHVyblxuICAgICAgICAgICAgICBsb2NhbCA9ICdkZWZhdWx0J1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSAnRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyJzpcbiAgICAgICAgICAgICAgbS5uYW1lc3BhY2Uuc2V0KHMuZXhwb3J0ZWQubmFtZSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydE1ldGEsICduYW1lc3BhY2UnLCB7XG4gICAgICAgICAgICAgICAgZ2V0KCkgeyByZXR1cm4gcmVzb2x2ZUltcG9ydChuKSB9LFxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICBjYXNlICdFeHBvcnRTcGVjaWZpZXInOlxuICAgICAgICAgICAgICBpZiAoIW4uc291cmNlKSB7XG4gICAgICAgICAgICAgICAgbS5uYW1lc3BhY2Uuc2V0KHMuZXhwb3J0ZWQubmFtZSwgYWRkTmFtZXNwYWNlKGV4cG9ydE1ldGEsIHMubG9jYWwpKVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGVsc2UgZmFsbHMgdGhyb3VnaFxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgbG9jYWwgPSBzLmxvY2FsLm5hbWVcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB0b2RvOiBKU0RvY1xuICAgICAgICAgIG0ucmVleHBvcnRzLnNldChzLmV4cG9ydGVkLm5hbWUsIHsgbG9jYWwsIGdldEltcG9ydDogKCkgPT4gcmVzb2x2ZUltcG9ydChuKSB9KVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gbVxuICB9XG5cbiAgLyoqXG4gICAqIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IGNoZWNrIGV4cGxpY2l0bHkgcmUtZXhwb3J0ZWQgbmFtZXMgZm9yIGV4aXN0ZW5jZVxuICAgKiBpbiB0aGUgYmFzZSBuYW1lc3BhY2UsIGJ1dCBpdCB3aWxsIGV4cGFuZCBhbGwgYGV4cG9ydCAqIGZyb20gJy4uLidgIGV4cG9ydHNcbiAgICogaWYgbm90IGZvdW5kIGluIHRoZSBleHBsaWNpdCBuYW1lc3BhY2UuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gIG5hbWVcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBgbmFtZWAgaXMgZXhwb3J0ZWQgYnkgdGhpcyBtb2R1bGUuXG4gICAqL1xuICBoYXMobmFtZSkge1xuICAgIGlmICh0aGlzLm5hbWVzcGFjZS5oYXMobmFtZSkpIHJldHVybiB0cnVlXG4gICAgaWYgKHRoaXMucmVleHBvcnRzLmhhcyhuYW1lKSkgcmV0dXJuIHRydWVcblxuICAgIC8vIGRlZmF1bHQgZXhwb3J0cyBtdXN0IGJlIGV4cGxpY2l0bHkgcmUtZXhwb3J0ZWQgKCMzMjgpXG4gICAgbGV0IGZvdW5kSW5uZXJNYXBOYW1lID0gZmFsc2VcbiAgICBpZiAobmFtZSAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICB0aGlzLmRlcGVuZGVuY2llcy5mb3JFYWNoKChkZXApID0+IHtcbiAgICAgICAgaWYgKCFmb3VuZElubmVyTWFwTmFtZSkge1xuICAgICAgICAgIGxldCBpbm5lck1hcCA9IGRlcCgpXG5cbiAgICAgICAgICAvLyB0b2RvOiByZXBvcnQgYXMgdW5yZXNvbHZlZD9cbiAgICAgICAgICBpZiAoaW5uZXJNYXAgJiYgaW5uZXJNYXAuaGFzKG5hbWUpKSBmb3VuZElubmVyTWFwTmFtZSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gZm91bmRJbm5lck1hcE5hbWVcbiAgfVxuXG4gIC8qKlxuICAgKiBlbnN1cmUgdGhhdCBpbXBvcnRlZCBuYW1lIGZ1bGx5IHJlc29sdmVzLlxuICAgKiBAcGFyYW0gIHtbdHlwZV19ICBuYW1lIFtkZXNjcmlwdGlvbl1cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICBbZGVzY3JpcHRpb25dXG4gICAqL1xuICBoYXNEZWVwKG5hbWUpIHtcbiAgICBpZiAodGhpcy5uYW1lc3BhY2UuaGFzKG5hbWUpKSByZXR1cm4geyBmb3VuZDogdHJ1ZSwgcGF0aDogW3RoaXNdIH1cblxuICAgIGlmICh0aGlzLnJlZXhwb3J0cy5oYXMobmFtZSkpIHtcbiAgICAgIGNvbnN0IHsgbG9jYWwsIGdldEltcG9ydCB9ID0gdGhpcy5yZWV4cG9ydHMuZ2V0KG5hbWUpXG4gICAgICAgICAgLCBpbXBvcnRlZCA9IGdldEltcG9ydCgpXG5cbiAgICAgIC8vIGlmIGltcG9ydCBpcyBpZ25vcmVkLCByZXR1cm4gZXhwbGljaXQgJ251bGwnXG4gICAgICBpZiAoaW1wb3J0ZWQgPT0gbnVsbCkgcmV0dXJuIHsgZm91bmQ6IHRydWUsIHBhdGg6IFt0aGlzXSB9XG5cbiAgICAgIC8vIHNhZmVndWFyZCBhZ2FpbnN0IGN5Y2xlcywgb25seSBpZiBuYW1lIG1hdGNoZXNcbiAgICAgIGlmIChpbXBvcnRlZC5wYXRoID09PSB0aGlzLnBhdGggJiYgbG9jYWwgPT09IG5hbWUpIHJldHVybiB7IGZvdW5kOiBmYWxzZSwgcGF0aDogW3RoaXNdIH1cblxuICAgICAgY29uc3QgZGVlcCA9IGltcG9ydGVkLmhhc0RlZXAobG9jYWwpXG4gICAgICBkZWVwLnBhdGgudW5zaGlmdCh0aGlzKVxuXG4gICAgICByZXR1cm4gZGVlcFxuICAgIH1cblxuXG4gICAgLy8gZGVmYXVsdCBleHBvcnRzIG11c3QgYmUgZXhwbGljaXRseSByZS1leHBvcnRlZCAoIzMyOClcbiAgICBsZXQgcmV0dXJuVmFsdWUgPSB7IGZvdW5kOiBmYWxzZSwgcGF0aDogW3RoaXNdIH1cbiAgICBpZiAobmFtZSAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICB0aGlzLmRlcGVuZGVuY2llcy5mb3JFYWNoKChkZXApID0+IHtcbiAgICAgICAgaWYgKCFyZXR1cm5WYWx1ZS5mb3VuZCkge1xuICAgICAgICAgIGxldCBpbm5lck1hcCA9IGRlcCgpXG4gICAgICAgICAgLy8gdG9kbzogcmVwb3J0IGFzIHVucmVzb2x2ZWQ/XG4gICAgICAgICAgaWYgKGlubmVyTWFwKSB7XG5cbiAgICAgICAgICAgIC8vIHNhZmVndWFyZCBhZ2FpbnN0IGN5Y2xlc1xuICAgICAgICAgICAgaWYgKGlubmVyTWFwLnBhdGggIT09IHRoaXMucGF0aCkge1xuXG4gICAgICAgICAgICAgIGxldCBpbm5lclZhbHVlID0gaW5uZXJNYXAuaGFzRGVlcChuYW1lKVxuICAgICAgICAgICAgICBpZiAoaW5uZXJWYWx1ZS5mb3VuZCkge1xuICAgICAgICAgICAgICAgIGlubmVyVmFsdWUucGF0aC51bnNoaWZ0KHRoaXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBpbm5lclZhbHVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIHJldHVyblZhbHVlXG4gIH1cblxuICBnZXQobmFtZSkge1xuICAgIGlmICh0aGlzLm5hbWVzcGFjZS5oYXMobmFtZSkpIHJldHVybiB0aGlzLm5hbWVzcGFjZS5nZXQobmFtZSlcblxuICAgIGlmICh0aGlzLnJlZXhwb3J0cy5oYXMobmFtZSkpIHtcbiAgICAgIGNvbnN0IHsgbG9jYWwsIGdldEltcG9ydCB9ID0gdGhpcy5yZWV4cG9ydHMuZ2V0KG5hbWUpXG4gICAgICAgICAgLCBpbXBvcnRlZCA9IGdldEltcG9ydCgpXG5cbiAgICAgIC8vIGlmIGltcG9ydCBpcyBpZ25vcmVkLCByZXR1cm4gZXhwbGljaXQgJ251bGwnXG4gICAgICBpZiAoaW1wb3J0ZWQgPT0gbnVsbCkgcmV0dXJuIG51bGxcblxuICAgICAgLy8gc2FmZWd1YXJkIGFnYWluc3QgY3ljbGVzLCBvbmx5IGlmIG5hbWUgbWF0Y2hlc1xuICAgICAgaWYgKGltcG9ydGVkLnBhdGggPT09IHRoaXMucGF0aCAmJiBsb2NhbCA9PT0gbmFtZSkgcmV0dXJuIHVuZGVmaW5lZFxuXG4gICAgICByZXR1cm4gaW1wb3J0ZWQuZ2V0KGxvY2FsKVxuICAgIH1cblxuICAgIC8vIGRlZmF1bHQgZXhwb3J0cyBtdXN0IGJlIGV4cGxpY2l0bHkgcmUtZXhwb3J0ZWQgKCMzMjgpXG4gICAgbGV0IHJldHVyblZhbHVlID0gdW5kZWZpbmVkXG4gICAgaWYgKG5hbWUgIT09ICdkZWZhdWx0Jykge1xuICAgICAgdGhpcy5kZXBlbmRlbmNpZXMuZm9yRWFjaCgoZGVwKSA9PiB7XG4gICAgICAgIGlmIChyZXR1cm5WYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGV0IGlubmVyTWFwID0gZGVwKClcbiAgICAgICAgICAvLyB0b2RvOiByZXBvcnQgYXMgdW5yZXNvbHZlZD9cbiAgICAgICAgICBpZiAoaW5uZXJNYXApIHtcblxuICAgICAgICAgICAgLy8gc2FmZWd1YXJkIGFnYWluc3QgY3ljbGVzXG4gICAgICAgICAgICBpZiAoaW5uZXJNYXAucGF0aCAhPT0gdGhpcy5wYXRoKSB7XG5cbiAgICAgICAgICAgICAgbGV0IGlubmVyVmFsdWUgPSBpbm5lck1hcC5nZXQobmFtZSlcbiAgICAgICAgICAgICAgaWYgKGlubmVyVmFsdWUgIT09IHVuZGVmaW5lZCkgcmV0dXJuVmFsdWUgPSBpbm5lclZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiByZXR1cm5WYWx1ZVxuICB9XG5cbiAgZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIHRoaXMubmFtZXNwYWNlLmZvckVhY2goKHYsIG4pID0+XG4gICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHYsIG4sIHRoaXMpKVxuXG4gICAgdGhpcy5yZWV4cG9ydHMuZm9yRWFjaCgoeyBnZXRJbXBvcnQsIGxvY2FsIH0sIG5hbWUpID0+IHtcbiAgICAgIGNvbnN0IHJlZXhwb3J0ZWQgPSBnZXRJbXBvcnQoKVxuICAgICAgLy8gY2FuJ3QgbG9vayB1cCBtZXRhIGZvciBpZ25vcmVkIHJlLWV4cG9ydHMgKCMzNDgpXG4gICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHJlZXhwb3J0ZWQgJiYgcmVleHBvcnRlZC5nZXQobG9jYWwpLCBuYW1lLCB0aGlzKVxuICAgIH0pXG5cbiAgICB0aGlzLmRlcGVuZGVuY2llcy5mb3JFYWNoKGRlcCA9PiBkZXAoKS5mb3JFYWNoKCh2LCBuKSA9PlxuICAgICAgbiAhPT0gJ2RlZmF1bHQnICYmIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdiwgbiwgdGhpcykpKVxuICB9XG5cbiAgLy8gdG9kbzoga2V5cywgdmFsdWVzLCBlbnRyaWVzP1xuXG4gIHJlcG9ydEVycm9ycyhjb250ZXh0LCBkZWNsYXJhdGlvbikge1xuICAgIGNvbnRleHQucmVwb3J0KHtcbiAgICAgIG5vZGU6IGRlY2xhcmF0aW9uLnNvdXJjZSxcbiAgICAgIG1lc3NhZ2U6IGBQYXJzZSBlcnJvcnMgaW4gaW1wb3J0ZWQgbW9kdWxlICcke2RlY2xhcmF0aW9uLnNvdXJjZS52YWx1ZX0nOiBgICtcbiAgICAgICAgICAgICAgICAgIGAke3RoaXMuZXJyb3JzXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGUgPT4gYCR7ZS5tZXNzYWdlfSAoJHtlLmxpbmVOdW1iZXJ9OiR7ZS5jb2x1bW59KWApXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbignLCAnKX1gLFxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBwYXJzZSBkb2NzIGZyb20gdGhlIGZpcnN0IG5vZGUgdGhhdCBoYXMgbGVhZGluZyBjb21tZW50c1xuICogQHBhcmFtICB7Li4uW3R5cGVdfSBub2RlcyBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHt7ZG9jOiBvYmplY3R9fVxuICovXG5mdW5jdGlvbiBjYXB0dXJlRG9jKGRvY1N0eWxlUGFyc2VycywgLi4ubm9kZXMpIHtcbiAgY29uc3QgbWV0YWRhdGEgPSB7fVxuXG4gIC8vICdzb21lJyBzaG9ydC1jaXJjdWl0cyBvbiBmaXJzdCAndHJ1ZSdcbiAgbm9kZXMuc29tZShuID0+IHtcbiAgICBpZiAoIW4ubGVhZGluZ0NvbW1lbnRzKSByZXR1cm4gZmFsc2VcblxuICAgIGZvciAobGV0IG5hbWUgaW4gZG9jU3R5bGVQYXJzZXJzKSB7XG4gICAgICBjb25zdCBkb2MgPSBkb2NTdHlsZVBhcnNlcnNbbmFtZV0obi5sZWFkaW5nQ29tbWVudHMpXG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIG1ldGFkYXRhLmRvYyA9IGRvY1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH0pXG5cbiAgcmV0dXJuIG1ldGFkYXRhXG59XG5cbmNvbnN0IGF2YWlsYWJsZURvY1N0eWxlUGFyc2VycyA9IHtcbiAganNkb2M6IGNhcHR1cmVKc0RvYyxcbiAgdG9tZG9jOiBjYXB0dXJlVG9tRG9jLFxufVxuXG4vKipcbiAqIHBhcnNlIEpTRG9jIGZyb20gbGVhZGluZyBjb21tZW50c1xuICogQHBhcmFtICB7Li4uW3R5cGVdfSBjb21tZW50cyBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHt7ZG9jOiBvYmplY3R9fVxuICovXG5mdW5jdGlvbiBjYXB0dXJlSnNEb2MoY29tbWVudHMpIHtcbiAgbGV0IGRvY1xuXG4gIC8vIGNhcHR1cmUgWFNEb2NcbiAgY29tbWVudHMuZm9yRWFjaChjb21tZW50ID0+IHtcbiAgICAvLyBza2lwIG5vbi1ibG9jayBjb21tZW50c1xuICAgIGlmIChjb21tZW50LnZhbHVlLnNsaWNlKDAsIDQpICE9PSAnKlxcbiAqJykgcmV0dXJuXG4gICAgdHJ5IHtcbiAgICAgIGRvYyA9IGRvY3RyaW5lLnBhcnNlKGNvbW1lbnQudmFsdWUsIHsgdW53cmFwOiB0cnVlIH0pXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvKiBkb24ndCBjYXJlLCBmb3Igbm93PyBtYXliZSBhZGQgdG8gYGVycm9ycz9gICovXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBkb2Ncbn1cblxuLyoqXG4gICogcGFyc2UgVG9tRG9jIHNlY3Rpb24gZnJvbSBjb21tZW50c1xuICAqL1xuZnVuY3Rpb24gY2FwdHVyZVRvbURvYyhjb21tZW50cykge1xuICAvLyBjb2xsZWN0IGxpbmVzIHVwIHRvIGZpcnN0IHBhcmFncmFwaCBicmVha1xuICBjb25zdCBsaW5lcyA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29tbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb21tZW50ID0gY29tbWVudHNbaV1cbiAgICBpZiAoY29tbWVudC52YWx1ZS5tYXRjaCgvXlxccyokLykpIGJyZWFrXG4gICAgbGluZXMucHVzaChjb21tZW50LnZhbHVlLnRyaW0oKSlcbiAgfVxuXG4gIC8vIHJldHVybiBkb2N0cmluZS1saWtlIG9iamVjdFxuICBjb25zdCBzdGF0dXNNYXRjaCA9IGxpbmVzLmpvaW4oJyAnKS5tYXRjaCgvXihQdWJsaWN8SW50ZXJuYWx8RGVwcmVjYXRlZCk6XFxzKiguKykvKVxuICBpZiAoc3RhdHVzTWF0Y2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGVzY3JpcHRpb246IHN0YXR1c01hdGNoWzJdLFxuICAgICAgdGFnczogW3tcbiAgICAgICAgdGl0bGU6IHN0YXR1c01hdGNoWzFdLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIGRlc2NyaXB0aW9uOiBzdGF0dXNNYXRjaFsyXSxcbiAgICAgIH1dLFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRyYXZlcnNlIGEgcGF0dGVybi9pZGVudGlmaWVyIG5vZGUsIGNhbGxpbmcgJ2NhbGxiYWNrJ1xuICogZm9yIGVhY2ggbGVhZiBpZGVudGlmaWVyLlxuICogQHBhcmFtICB7bm9kZX0gICBwYXR0ZXJuXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWN1cnNpdmVQYXR0ZXJuQ2FwdHVyZShwYXR0ZXJuLCBjYWxsYmFjaykge1xuICBzd2l0Y2ggKHBhdHRlcm4udHlwZSkge1xuICAgIGNhc2UgJ0lkZW50aWZpZXInOiAvLyBiYXNlIGNhc2VcbiAgICAgIGNhbGxiYWNrKHBhdHRlcm4pXG4gICAgICBicmVha1xuXG4gICAgY2FzZSAnT2JqZWN0UGF0dGVybic6XG4gICAgICBwYXR0ZXJuLnByb3BlcnRpZXMuZm9yRWFjaCgoeyB2YWx1ZSB9KSA9PiB7XG4gICAgICAgIHJlY3Vyc2l2ZVBhdHRlcm5DYXB0dXJlKHZhbHVlLCBjYWxsYmFjaylcbiAgICAgIH0pXG4gICAgICBicmVha1xuXG4gICAgY2FzZSAnQXJyYXlQYXR0ZXJuJzpcbiAgICAgIHBhdHRlcm4uZWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgICBpZiAoZWxlbWVudCA9PSBudWxsKSByZXR1cm5cbiAgICAgICAgcmVjdXJzaXZlUGF0dGVybkNhcHR1cmUoZWxlbWVudCwgY2FsbGJhY2spXG4gICAgICB9KVxuICAgICAgYnJlYWtcbiAgfVxufVxuIl19